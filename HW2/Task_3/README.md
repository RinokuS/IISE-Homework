# Соколовский Вацлав, БПИ191
## LF stack

В [данной папке](https://github.com/RinokuS/IISE-Homework/tree/main/HW2/Task_3) представлены исходники исследовательского проекта на языке C++.

## Цель работы
Изучение структуры ```Lock-Free Stack``` из библиотеки ```Catboost```.

## №1 Внутренние структуры и поля класса
В реализации класса представлено всего 3 поля:
* TNode* Head;
* TNode* FreePtr;
* TAtomic DequeueCount;

Опишем каждое подробнее:
### Head
Как понятно из названия, это поле представляет из себя голову стека, ничего сверхестественного! Фактически, в этом поле хранится сам стек, ибо благодаря головному элементу мы можем перейди на следующий и так далее, пока не дойдем до хвоста. <br> Представлено поле указателем на тип ```TNode```, который, если кратко, представляет собой реализацию одного элемента стека, более подробно о нем будет указано в самом конце параграфа о внутренних структурах и полях.

### FreePtr
Это поле, в отличии от предыдущего, уже не так легко разобрать просто по названию. Но благодаря небольшому ресерчу кода можно убедиться, что это поле предназначено для утилизации элементов, которые были вытащены из стека в случае, если счетчик активных 'вытаскиваний' не равен нулю. <br>
Звучит сложно, но вот пояснение: в случае, если вытаскивает элемент из стека единственный поток, то нам не нужно беспокоиться об правильно удалении элемента, мы просто используем ```delete```, но в случае, когда еще какой-то поток параллельно вытаскивает элементы из стека, если мы удалим элемент, то получим неопределенное состояние. Именно для этого, в случае работы одновременно нескольких потоков, элементы не удаляются сразу а проталкиваются в отельный односвязный список, головой которого является наше поле - ```FreePtr```. <br>
В конце операции выталкивания каждый поток проверяет, что он остался последним, и если это так - удаляет за собой сразу все элементы, которые были вытолкнуты потоками и попали в наш список ```FreePtr```.

### DequeueCount
Данное поле, как следует из его типа и названия, является атомарным счетчиков производимых над стеком в данный момент операций выталкивания. <br>
Этот счетчик нужен нам, так как операция выталкивания, в отличии от операции вставки, не может быть реализована атомарно (нам нужно правильно освобождать память, чтобы не было утечек) и он помогает нам следить, в какой момент времени мы можем безопасно освободить память от элементов, которые были из стека вытолкнуты.

### TNode 
```TNode``` является внутренним типом реализации, которую мы рассматриваем. <br>
Представляет он из себя элемент простого односвязного списка с поддержкой шаблонов для типизации хранимого значения. В каждом элементе хранится его значение, тип которого представлен шаблоном, и ссылка (указатель) на следующий элемент списка.

## №2 Методы push, pop, top

### push
Методом ```push``` в данной реализации является метод ```void Enqueue```, у него доступно несколько перегрузок, а также вспомогательный метод ```EnqueueAll```, помогающий удобно добавить в стек сразу коллекцию значений, представимую двумя дефолтными итераторами ```begin``` и ```end```. <br>
Все, чем занимается данная группа методов:
1. сбор односвязного списка элементов стека из вставленных элементов (если вставляется один, то и список будет с одним элементом)
2. атомарное получение текущей головы стека
3. присоединение текущей головы стека к концу сгенерированного в пункте 1 списка и назначение головы нового списка головой стека. Все это делается в бесконечном цикле одной атомарной операцией - сравнение с обменом. В случае успеха операции, цикл обрывается.

### pop
Методом ```pop``` в данной реализации является метод ```bool Dequeue```, у него, также как и у ```Enqueue```, есть собрат ```bool DequeueAll```, который вытаскивает из стека сразу все его элементы. <br>
Примерное описание работы алгоритма:
1. инкрементируем счетчик ```DequeueCount```
2. входим в цикл. начальным значением переменной цикла будет атомарное получение актуальной головы стека, в конце цикла - проверка на то, что переменная является ```nullptr```,  и, если это не так, начинаем новую итерацию с атомарным получением актуальной головы стека. Данный цикл поможет нам очистить стек весь в стек даже в случае, если во время нашей работы кто-то добавил новые элементы. 
3. внутри цикла мы вытаскиваем значения из нужных нод по указателю с помощью move-семантики
4. пытаемся освободить память, которая уже в ```FreePtr```
5. декрементируем счетчик ```DequeueCount``` и проверяем, сколько действующих операций выталкивания в данный момент
6. если ни одной - просто удаляем элементы с помощью ```delete```, иначе - добавляем вытолкнутый элемент в ```FreePtr``` и выходим из функции с положительным результатом (в случае ```Dequeue```)  или продолжаем итерацию по элементам для дальнейшего выталкивания (в случае ```DequeueAll```)


### top
По-моему мнение, основным препятствием в реализации данной функции в случае Lock-Free стэка являлась невозможность получить данные из стека, не удаляя их. <br>
Если посмотреть в код, то в случае Dequeue мы в первую очередь забираем и инвалидируем данные выталкиваемой ноды, ибо мы не можем гарантировать их дальнейшую целостность при проведении полной операции выталкивания. <br>
Также, возможно, обяъснение еще проще - операция копирования больших структур не может обещать сохранность данных во время копирования при многопоточности, в отличии от move-семантики. Но, так как ```top()``` должен быть константным методом по своей природе, его реализация в полобных структурах невозможна.

## №3 Агрейд
В файле ```lfstack.h``` представлена попытка копирования реализованной в catboost структуры с заменой Atomic-макросов на std::atomic. Не удалось, к сожалению, нормально поправить все ошибки и собрать проект из-за шаблонов, которые не пропускают ошибки в IDE. Но я заменил почти все макросы на соответствующие им функции учитывая правильный порядок следования аргументов, который в std::atomic немного отличаетя от Atomic-макросов в catboost. <br>
Нвдеюсь, это хоть на сколько-то зачтется :(
